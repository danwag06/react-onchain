#!/usr/bin/env node

import { Command } from 'commander';
import { existsSync } from 'fs';
import { resolve } from 'path';
import chalk from 'chalk';
import ora from 'ora';
import { deployToChain, generateManifest, saveManifestWithHistory } from './orchestrator.js';
import { getVersionDetails, getVersionInfoAndHistory } from './versioningInscriptionHandler.js';
import { config as envConfig, DEFAULT_CONFIG } from './config.js';
import type { DeploymentConfig, InscribedFile, DeploymentManifestHistory } from './types.js';
import { readFile, writeFile } from 'fs/promises';

const program = new Command();

/**
 * Format bytes to human-readable string
 */
function formatBytes(bytes: number): string {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * Load content service URL from manifest (if exists) or fallback to config
 * Prioritizes manifest value since it represents what was used during deployment
 */
async function loadContentUrl(manifestPath: string = 'deployment-manifest.json'): Promise<string> {
  if (existsSync(manifestPath)) {
    try {
      const manifestJson = await readFile(manifestPath, 'utf-8');
      const manifestData = JSON.parse(manifestJson);

      // Check new format (history)
      if ('manifestVersion' in manifestData && 'deployments' in manifestData) {
        const history = manifestData as DeploymentManifestHistory;
        if (history.deployments.length > 0) {
          const latestDeployment = history.deployments[history.deployments.length - 1];
          if (latestDeployment.ordinalContentUrl) {
            return latestDeployment.ordinalContentUrl;
          }
        }
      } else if ('ordinalContentUrl' in manifestData && manifestData.ordinalContentUrl) {
        // Old format (single deployment)
        return manifestData.ordinalContentUrl;
      }
    } catch (error) {
      // Failed to read/parse manifest, fall through to config
    }
  }

  // Fallback to environment config
  return envConfig.ordinalContentUrl;
}

/**
 * Display file size summary table
 */
function displaySummary(inscriptions: InscribedFile[], totalSize: number): void {
  console.log(chalk.bold.white('üìÑ Inscribed Files'));
  console.log(chalk.gray('‚îÄ'.repeat(70)));

  // File rows
  inscriptions.forEach((file, index) => {
    const fileName =
      file.originalPath.length > 35 ? '...' + file.originalPath.slice(-32) : file.originalPath;

    const number = chalk.gray(`${String(index + 1).padStart(2)}. `);
    const name = chalk.white(fileName.padEnd(35));
    const size = chalk.yellow(formatBytes(file.size).padEnd(10));
    const txid = chalk.gray(file.txid.slice(0, 8) + '...');

    console.log(`  ${number}${name} ${size} ${txid}`);
  });

  console.log(chalk.gray('‚îÄ'.repeat(70)));
  console.log(
    chalk.gray('  TOTAL'.padEnd(39)) +
      chalk.bold.green(formatBytes(totalSize).padEnd(11)) +
      chalk.gray(`${inscriptions.length} file${inscriptions.length !== 1 ? 's' : ''}`)
  );
  console.log(chalk.gray('‚îÄ'.repeat(70)));
  console.log();
}

/**
 * Save deployment configuration to .env file
 * Allows subsequent deployments to use stored config
 */
async function saveDeploymentEnv(config: {
  paymentKey: string;
  buildDir: string;
  versioningContract?: string;
  ordinalContentUrl: string;
  satsPerKb: number;
}): Promise<void> {
  const envPath = resolve('.env');
  const gitignorePath = resolve('.gitignore');
  const timestamp = new Date().toISOString().split('T')[0];

  // Ensure .gitignore exists and contains .env
  if (existsSync(gitignorePath)) {
    // Read existing .gitignore
    const gitignoreContent = await readFile(gitignorePath, 'utf-8');
    const lines = gitignoreContent.split('\n');

    // Check if .env is already in .gitignore
    const hasEnv = lines.some((line) => line.trim() === '.env');

    if (!hasEnv) {
      // Add .env to .gitignore
      const updatedContent = gitignoreContent.endsWith('\n')
        ? gitignoreContent + '.env\n'
        : gitignoreContent + '\n.env\n';
      await writeFile(gitignorePath, updatedContent, 'utf-8');
    }
  } else {
    // Create .gitignore with .env
    await writeFile(gitignorePath, '.env\n', 'utf-8');
  }

  const envContent = `# React OnChain Deployment Configuration
# Auto-generated by react-onchain on ${timestamp}
#
# This file contains your deployment settings for convenience.
# Subsequent deployments can use these values automatically.
#
# ‚ö†Ô∏è  SECURITY WARNING ‚ö†Ô∏è
# This file contains your PRIVATE KEY!
# - NEVER commit this file to version control
# - NEVER share this file with anyone
# - Keep this file secure and private
#
# The .env file is already in .gitignore to help protect your keys.

# Payment private key (WIF format)
# Used to sign transactions during deployment
# Destination address is automatically derived from this key
REACT_ONCHAIN_PAYMENT_KEY=${config.paymentKey}

# Build directory to deploy
BUILD_DIR=${config.buildDir}

# Versioning contract outpoint (from first deployment)
${config.versioningContract ? `VERSIONING_CONTRACT=${config.versioningContract}` : '# VERSIONING_CONTRACT=<will be set after first deployment>'}

# Ordinal content delivery URL (base URL without /content path)
# Relative inscription URLs (/content/{outpoint}) are appended to this
ORDINAL_CONTENT_URL=${config.ordinalContentUrl}

# Transaction fee rate (satoshis per KB)
SATS_PER_KB=${config.satsPerKb}

# For subsequent deployments, you can now just run:
# npx react-onchain deploy --version-tag "1.1.0" --version-description "Bug fixes"
`;

  await writeFile(envPath, envContent, 'utf-8');
}

program
  .name('react-onchain')
  .description('Deploy React applications to BSV blockchain using 1Sat Ordinals')
  .version('1.0.0');

program
  .command('deploy')
  .description('Deploy a React build directory to the blockchain')
  .option('-b, --build-dir <directory>', 'Build directory to deploy', envConfig.buildDir)
  .option('-p, --payment-key <wif>', 'Payment private key (WIF format)', envConfig.paymentKey)
  .option('-c, --change <address>', 'Change address (optional)', envConfig.changeAddress)
  .option('-s, --sats-per-kb <number>', 'Satoshis per KB for fees', String(envConfig.satsPerKb))
  .option('-m, --manifest <file>', 'Output manifest file', envConfig.manifestFile)
  .option('--dry-run', 'Simulate deployment without broadcasting transactions', envConfig.dryRun)
  .option(
    '--ordinal-content-url <url>',
    'Ordinal content delivery URL',
    envConfig.ordinalContentUrl
  )
  .option('--ordinal-indexer-url <url>', 'Ordinal indexer API URL', envConfig.ordinalIndexerUrl)
  .option(
    '--version-tag <string>',
    'Version tag for this deployment (e.g., "1.0.0")',
    envConfig.versionTag
  )
  .option(
    '--version-description <string>',
    'Description/changelog for this version',
    envConfig.versionDescription
  )
  .option(
    '--versioning-contract <outpoint>',
    'Existing versioning contract outpoint (txid_vout)',
    envConfig.versioningContract
  )
  .option('--app-name <string>', 'Application name for new versioning contract', envConfig.appName)
  .action(async (options) => {
    try {
      // Step 1: Load previous manifest to get stored configuration
      const manifestPath = resolve('deployment-manifest.json');
      let previousConfig: {
        buildDir?: string;
        versioningContract?: string;
      } = {};

      if (existsSync(manifestPath)) {
        try {
          const manifestJson = await readFile(manifestPath, 'utf-8');
          const manifestData = JSON.parse(manifestJson);

          if ('manifestVersion' in manifestData && 'deployments' in manifestData) {
            // New format - use top-level originVersioningInscription, last deployment for other config
            const history = manifestData;
            if (history.deployments.length > 0) {
              const lastDeployment = history.deployments[history.deployments.length - 1];

              // Origin versioning inscription from top-level field
              previousConfig.versioningContract = history.originVersioningInscription;
              // Build dir from last deployment
              previousConfig.buildDir = lastDeployment.buildDir;
            }
          } else if ('timestamp' in manifestData && 'entryPoint' in manifestData) {
            // Old format - single deployment
            previousConfig.versioningContract =
              manifestData.originVersioningInscription || manifestData.versioningContract;
            previousConfig.buildDir = manifestData.buildDir;
          }
        } catch (error) {
          // Failed to load manifest - continue without previous config
        }
      }

      // Step 2: Auto-detect build directory if not provided
      // Check if buildDir was explicitly set (not default)
      const buildDirExplicitlySet = options.buildDir !== DEFAULT_CONFIG.buildDir;

      if (!buildDirExplicitlySet) {
        // Try previous manifest first
        if (previousConfig.buildDir && existsSync(previousConfig.buildDir)) {
          options.buildDir = previousConfig.buildDir;
        } else {
          // Auto-detect common build directories
          const commonBuildDirs = ['dist', 'build', 'out', '.next/standalone', 'public'];
          for (const dir of commonBuildDirs) {
            const fullPath = resolve(dir);
            if (existsSync(fullPath) && existsSync(resolve(fullPath, 'index.html'))) {
              options.buildDir = dir;
              break;
            }
          }

          if (!options.buildDir) {
            console.error(
              chalk.red(
                'Error: Could not auto-detect build directory. Please specify with --build-dir'
              )
            );
            console.error(chalk.gray('  Tried: ' + commonBuildDirs.join(', ')));
            process.exit(1);
          }
        }
      }

      // Step 3: Apply configuration precedence for other options
      // Order: CLI flag > Previous manifest > Environment variable > Default

      // Versioning contract (use origin from first deployment)
      if (!options.versioningContract && previousConfig.versioningContract) {
        options.versioningContract = previousConfig.versioningContract;
      }

      // Validate required options (unless dry-run)
      if (!options.dryRun) {
        if (!options.paymentKey) {
          console.error(chalk.red('Error: --payment-key is required (or use --dry-run)'));
          process.exit(1);
        }
      } else {
        // In dry-run mode, use dummy values if not provided
        if (!options.paymentKey) {
          options.paymentKey = 'L1aB2cD3eF4gH5iJ6kL7mN8oP9qR0sT1uV2wX3yZ4a5b6c7d8e9f0';
        }
      }

      // Resolve build directory
      const buildDir = resolve(options.buildDir);

      if (!existsSync(buildDir)) {
        console.error(chalk.red(`Error: Build directory not found: ${buildDir}`));
        process.exit(1);
      }

      // Check for index.html
      const indexPath = resolve(buildDir, 'index.html');
      if (!existsSync(indexPath)) {
        console.error(chalk.red(`Error: index.html not found in build directory: ${buildDir}`));
        process.exit(1);
      }

      // Beautiful header
      console.log();
      console.log(
        chalk.cyan('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó')
      );
      console.log(
        chalk.cyan('‚ïë') +
          chalk.bold.white('                  React OnChain Deployment                     ') +
          chalk.cyan('‚ïë')
      );
      console.log(
        chalk.cyan('‚ïë') +
          chalk.gray('          Deploy your React app to the BSV blockchain          ') +
          chalk.cyan('‚ïë')
      );
      console.log(
        chalk.cyan('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù')
      );
      console.log();

      if (options.dryRun) {
        console.log(
          chalk.yellow.bold('‚ö†Ô∏è  DRY RUN MODE') +
            chalk.yellow(' - No transactions will be broadcast\n')
        );
      }

      // Configuration section
      console.log(chalk.bold.white('üìã Configuration'));
      console.log(chalk.gray('‚îÄ'.repeat(70)));
      console.log(chalk.gray('  Build directory: ') + chalk.cyan(buildDir));
      console.log(chalk.gray('  Fee rate:        ') + chalk.cyan(`${options.satsPerKb} sats/KB`));

      // Display versioning info if enabled
      if (options.versionTag) {
        console.log(chalk.gray('  Version:         ') + chalk.magenta(options.versionTag));
        if (options.versionDescription) {
          console.log(chalk.gray('  Description:     ') + chalk.white(options.versionDescription));
        }
        if (options.versioningContract) {
          console.log(chalk.gray('  Contract:        ') + chalk.yellow(options.versioningContract));
        } else if (options.appName) {
          console.log(
            chalk.gray('  App name:        ') +
              chalk.green(options.appName) +
              chalk.gray(' (new versioning inscription)')
          );
        }
      }
      console.log(chalk.gray('‚îÄ'.repeat(70)));
      console.log();

      const config: DeploymentConfig = {
        buildDir,
        paymentKey: options.paymentKey,
        changeAddress: options.change,
        satsPerKb: parseInt(options.satsPerKb, 10),
        dryRun: options.dryRun,
        ordinalContentUrl: options.ordinalContentUrl,
        ordinalIndexerUrl: options.ordinalIndexerUrl,
        enableVersioning: !!options.versionTag,
        version: options.versionTag,
        versionDescription: options.versionDescription,
        versioningContract: options.versioningContract,
        appName: options.appName,
      };

      // Capture content URL for displaying absolute URLs in logs
      const contentUrlForDisplay = config.ordinalContentUrl || envConfig.ordinalContentUrl;

      let spinner = ora({ text: 'Analyzing build directory...', color: 'cyan' }).start();

      const result = await deployToChain(config, {
        onAnalysisStart: () => {
          spinner.text = 'üîç Analyzing build directory...';
        },
        onAnalysisComplete: (count) => {
          spinner.succeed(chalk.bold.green(`Found ${chalk.white(count)} files to inscribe`));
          console.log();
          console.log(chalk.bold.white('‚ö° Inscribing to BSV Blockchain'));
          console.log(chalk.gray('‚îÄ'.repeat(70)));
          spinner = ora({ text: 'Preparing inscription...', color: 'yellow' }).start();
        },
        onInscriptionStart: (file, current, total) => {
          const percent = Math.round((current / total) * 100);
          const progressBar =
            '‚ñà'.repeat(Math.floor(percent / 5)) + '‚ñë'.repeat(20 - Math.floor(percent / 5));
          spinner.text =
            chalk.yellow(`[${progressBar}] ${percent}%`) +
            chalk.gray(` Inscribing `) +
            chalk.cyan(file) +
            chalk.gray(` (${current}/${total})`);
        },
        onInscriptionComplete: (file, url) => {
          const absoluteUrl = contentUrlForDisplay + url;
          const shortUrl = absoluteUrl.split('/').pop() || url;
          spinner.stopAndPersist({
            symbol: chalk.green('‚úì'),
            text: chalk.white(file.padEnd(35)) + chalk.gray(' ‚Üí ') + chalk.cyan(shortUrl),
          });
          spinner.start('');
        },
        onInscriptionSkipped: (file, url) => {
          const absoluteUrl = contentUrlForDisplay + url;
          const shortUrl = absoluteUrl.split('/').pop() || url;
          spinner.stopAndPersist({
            symbol: chalk.blue('‚Üª'),
            text:
              chalk.white(file.padEnd(35)) +
              chalk.gray(' ‚Üí ') +
              chalk.cyan(shortUrl) +
              chalk.gray(' (cached)'),
          });
          spinner.start('');
        },
        onDeploymentComplete: () => {
          spinner.stop();
          console.log(chalk.gray('‚îÄ'.repeat(70)));
        },
      });

      // Success banner
      console.log();
      console.log(
        chalk.green('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó')
      );
      console.log(
        chalk.green('‚ïë') +
          chalk.bold.white('                     Deployment Complete!                      ') +
          chalk.green('‚ïë')
      );
      console.log(
        chalk.green('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù')
      );
      console.log();

      if (options.dryRun) {
        console.log(
          chalk.yellow.bold('‚ö†Ô∏è  DRY RUN') + chalk.yellow(' - Mock transaction IDs shown below\n')
        );
      }

      // Display file size summary
      displaySummary(result.inscriptions, result.totalSize);

      // Stats section
      console.log(chalk.bold.white('üìä Deployment Stats'));
      console.log(chalk.gray('‚îÄ'.repeat(70)));
      console.log(chalk.gray('  Total files:      ') + chalk.white(result.inscriptions.length));
      console.log(chalk.gray('  Total size:       ') + chalk.white(formatBytes(result.totalSize)));
      console.log(
        chalk.gray('  Total cost:       ') + chalk.white(`~${result.totalCost} satoshis`)
      );
      console.log(chalk.gray('  Transactions:     ') + chalk.white(result.txids.length));
      console.log(chalk.gray('‚îÄ'.repeat(70)));
      console.log();

      // Display versioning information if available
      if (result.versioningContract) {
        console.log(chalk.bold.magenta('üì¶ Versioning'));
        console.log(chalk.gray('‚îÄ'.repeat(70)));
        console.log(chalk.gray('  Contract:         ') + chalk.yellow(result.versioningContract));
        if (result.version) {
          console.log(chalk.gray('  Version:          ') + chalk.magenta(result.version));
        }

        // Check if this is a first deployment (no --versioning-contract provided)
        const isFirstDeployment = !options.versioningContract;

        if (isFirstDeployment) {
          // First deployment - no version redirect script injected
          console.log(
            chalk.gray('  Version redirect: ') +
              chalk.yellow('Not available yet (first deployment)')
          );
          console.log(
            chalk.gray('                    ') + chalk.gray('Will be enabled on next deployment')
          );
          console.log();
          console.log(chalk.gray('  üí° To deploy next version:'));
          console.log(chalk.cyan(`     npx react-onchain deploy \\`));
          console.log(chalk.cyan(`       --version-tag "2.0.0" \\`));
          console.log(chalk.cyan(`       --version-description "Added new features"`));
          console.log();
          console.log(chalk.gray('     (all config auto-loaded from .env and manifest)'));
        } else {
          // Subsequent deployment - version redirect script was injected
          console.log(chalk.gray('  Version redirect: ') + chalk.green('‚úì Enabled'));
          console.log(
            chalk.gray('  Version access:   ') +
              chalk.cyan(`${result.ordinalContentUrl + result.entryPointUrl}?version=<VERSION>`)
          );
        }

        console.log(chalk.gray('‚îÄ'.repeat(70)));
        console.log();

        // Show available query commands
        console.log(chalk.bold.white('üìã Available Queries'));
        console.log(chalk.gray('‚îÄ'.repeat(70)));
        console.log(
          chalk.gray('Versioning Origin: ') + chalk.cyan(result.versioningContract || 'N/A')
        );
        console.log(chalk.gray('Current Version: ') + chalk.cyan(result.version || 'N/A'));
        console.log(
          chalk.gray('  ‚Ä¢ Version history:   ') +
            chalk.cyan(`npx react-onchain version:history <ORIGIN>`)
        );
        console.log(
          chalk.gray('  ‚Ä¢ Version summary:   ') +
            chalk.cyan(`npx react-onchain version:summary <ORIGIN>`)
        );
        console.log(
          chalk.gray('  ‚Ä¢ Version details:   ') +
            chalk.cyan(`npx react-onchain version:info <ORIGIN> <VERSION>`)
        );
        console.log(chalk.gray('‚îÄ'.repeat(70)));
        console.log();
      }

      // Save manifest with history
      const manifest = generateManifest(result);
      const outputManifestPath = options.dryRun
        ? options.manifest.replace('.json', '-dry-run.json')
        : options.manifest;
      const history = await saveManifestWithHistory(manifest, outputManifestPath);

      // Save deployment configuration to .env (only for real deployments)
      if (!options.dryRun) {
        await saveDeploymentEnv({
          paymentKey: options.paymentKey!,
          buildDir: buildDir,
          versioningContract: result.versioningContract,
          ordinalContentUrl: result.ordinalContentUrl || envConfig.ordinalContentUrl,
          satsPerKb: parseInt(options.satsPerKb || '1', 10),
        });
      }

      // Show deployment count
      const deploymentNum = history.totalDeployments;
      if (deploymentNum === 1) {
        console.log(chalk.gray(`üìÑ Manifest saved to: ${manifestPath}`));
        if (!options.dryRun) {
          console.log(chalk.gray(`üîê Configuration saved to: .env`));
        }
      } else {
        console.log(
          chalk.gray(`üìÑ Manifest saved to: ${manifestPath} `) +
            chalk.cyan(`(Deployment #${deploymentNum})`)
        );
        if (!options.dryRun) {
          console.log(chalk.gray(`üîê Configuration updated: .env`));
        }
      }
      console.log();

      if (options.dryRun) {
        console.log(
          chalk.yellow('‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ')
        );
        console.log(
          chalk.yellow('‚îÇ') +
            chalk.yellow.bold(' This was a dry run. To deploy for real, remove --dry-run flag. ') +
            chalk.yellow('‚îÇ')
        );
        console.log(
          chalk.yellow('‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ')
        );
        console.log();
      } else {
        console.log(
          chalk.green('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó')
        );
        console.log(
          chalk.green('‚ïë') +
            chalk.bold.white('          Your app is now live on the blockchain!             ') +
            chalk.green('‚ïë')
        );
        console.log(
          chalk.green('‚ïë') +
            '                                                                   ' +
            chalk.green('‚ïë')
        );
        console.log(
          chalk.green('‚ïë') +
            chalk.gray('  Note: It may take ~10 minutes for full confirmation           ') +
            chalk.green('‚ïë')
        );
        console.log(
          chalk.green('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù')
        );
        console.log();
        console.log(
          chalk.bold.cyan('  üîó Visit: ') +
            chalk.cyan.underline(result.ordinalContentUrl + result.entryPointUrl)
        );
        console.log();
      }
    } catch (error) {
      console.error(chalk.red('\n‚ùå Deployment failed:\n'));
      console.error(chalk.red(error instanceof Error ? error.message : String(error)));
      process.exit(1);
    }
  });

// Version history command
program
  .command('version:history <inscription>')
  .description('Show version history for a versioning inscription')
  .option('-m, --manifest <file>', 'Path to manifest file', 'deployment-manifest.json')
  .action(async (inscriptionOrigin, options) => {
    try {
      console.log(chalk.bold('\nüìö Version History\n'));
      console.log(chalk.gray(`Inscription: ${inscriptionOrigin}\n`));

      const spinner = ora('Loading version history...').start();

      const { history, info } = await getVersionInfoAndHistory(inscriptionOrigin);

      spinner.succeed(chalk.green(`Found ${history.length} version(s)`));

      console.log(chalk.gray('‚îÄ'.repeat(70)));
      console.log(
        chalk.gray('Version'.padEnd(15)) +
          chalk.gray('Description'.padEnd(40)) +
          chalk.gray('Status')
      );
      console.log(chalk.gray('‚îÄ'.repeat(70)));

      for (let i = 0; i < history.length; i++) {
        const { version, description } = history[i];
        const isLatest = i === 0;
        const status = isLatest ? chalk.green('(latest)') : '';
        const truncatedDesc =
          description.length > 37 ? description.substring(0, 34) + '...' : description;
        console.log(
          chalk.cyan(version.padEnd(15)) + chalk.white(truncatedDesc.padEnd(40)) + status
        );
      }

      console.log(chalk.gray('‚îÄ'.repeat(70)));
      console.log(chalk.gray(`\nApp: ${info.appName}`));
      console.log(chalk.gray(`Origin: ${info.originOutpoint}\n`));
    } catch (error) {
      console.error(chalk.red('\n‚ùå Failed to get version history:\n'));
      console.error(chalk.red(error instanceof Error ? error.message : String(error)));
      process.exit(1);
    }
  });

// Version info command
program
  .command('version:info <inscription> <version>')
  .description('Get detailed information about a specific version')
  .option('-m, --manifest <file>', 'Path to manifest file', 'deployment-manifest.json')
  .action(async (inscriptionOrigin, version, options) => {
    try {
      console.log(chalk.bold('\nüì¶ Version Details\n'));

      const spinner = ora(`Loading version ${version}...`).start();

      const contentUrl = await loadContentUrl(options.manifest);
      const details = await getVersionDetails(inscriptionOrigin, version);

      if (!details) {
        spinner.fail(chalk.red(`Version ${version} not found`));
        process.exit(1);
      }

      spinner.succeed(chalk.green(`Version ${version} found`));

      console.log(chalk.gray('‚îÄ'.repeat(70)));
      console.log(chalk.bold('Version:     ') + chalk.cyan(details.version));
      console.log(chalk.bold('Outpoint:    ') + chalk.gray(details.outpoint));
      console.log(
        chalk.bold('URL:         ') + chalk.cyan(`${contentUrl}/content/${details.outpoint}`)
      );
      console.log(chalk.bold('Description: ') + details.description);
      console.log(chalk.gray('‚îÄ'.repeat(70)));
      console.log();
    } catch (error) {
      console.error(chalk.red('\n‚ùå Failed to get version info:\n'));
      console.error(chalk.red(error instanceof Error ? error.message : String(error)));
      process.exit(1);
    }
  });

// Inscription summary command
program
  .command('version:summary <inscription>')
  .description('Get information about a versioning inscription')
  .option('-m, --manifest <file>', 'Path to manifest file', 'deployment-manifest.json')
  .action(async (inscriptionOrigin, options) => {
    try {
      console.log(chalk.bold('\nüìã Inscription Information\n'));

      const spinner = ora('Loading inscription info...').start();

      const { info, history } = await getVersionInfoAndHistory(inscriptionOrigin);

      spinner.succeed(chalk.green('Inscription info loaded'));

      console.log(chalk.gray('‚îÄ'.repeat(70)));
      console.log(chalk.bold('Inscription:   ') + chalk.cyan(info.outpoint));
      console.log(chalk.bold('App Name:      ') + info.appName);
      console.log(chalk.bold('Origin:        ') + chalk.gray(info.originOutpoint));
      console.log(chalk.bold('Total Versions:') + ` ${history.length}`);
      console.log(
        chalk.bold('Latest Version:') +
          ` ${history.length > 0 ? chalk.cyan(history[0].version) : chalk.gray('(none)')}`
      );
      console.log(chalk.gray('‚îÄ'.repeat(70)));
      console.log();
    } catch (error) {
      console.error(chalk.red('\n‚ùå Failed to get inscription info:\n'));
      console.error(chalk.red(error instanceof Error ? error.message : String(error)));
      process.exit(1);
    }
  });

// Manifest history command
program
  .command('manifest:history')
  .description('Show local deployment history from manifest file')
  .option('-m, --manifest <file>', 'Path to manifest file', 'deployment-manifest.json')
  .action(async (options) => {
    try {
      const manifestPath = resolve(options.manifest);

      if (!existsSync(manifestPath)) {
        console.error(chalk.red(`\n‚ùå Manifest file not found: ${manifestPath}\n`));
        process.exit(1);
      }

      const spinner = ora('Loading deployment history...').start();

      const data = await readFile(manifestPath, 'utf-8');
      const parsed = JSON.parse(data);

      // Check format
      if (!('manifestVersion' in parsed && 'deployments' in parsed)) {
        spinner.fail(chalk.yellow('Old manifest format detected'));
        console.log(chalk.yellow('\nThis manifest uses the old single-deployment format.'));
        console.log(chalk.gray('Deploy again to migrate to the new history-tracking format.\n'));
        process.exit(0);
      }

      const history = parsed as DeploymentManifestHistory;
      spinner.succeed(chalk.green(`Found ${history.totalDeployments} deployment(s)`));

      console.log(chalk.bold('\nüìö Deployment History\n'));
      console.log(chalk.gray('‚îÄ'.repeat(70)));

      // Show header
      console.log(
        chalk.gray('#'.padEnd(4)) +
          chalk.gray('Version'.padEnd(12)) +
          chalk.gray('Timestamp'.padEnd(22)) +
          chalk.gray('Files'.padEnd(8)) +
          chalk.gray('Size')
      );
      console.log(chalk.gray('‚îÄ'.repeat(70)));

      // Show each deployment
      history.deployments.forEach((deployment, index) => {
        const num = String(index + 1).padEnd(4);
        const version = (deployment.version || 'N/A').padEnd(12);
        const timestamp = new Date(deployment.timestamp).toLocaleString().padEnd(22);
        const files = String(deployment.totalFiles).padEnd(8);
        const size = formatBytes(deployment.totalSize);

        const isLatest = index === history.deployments.length - 1;
        const latestLabel = isLatest ? chalk.green(' (latest)') : '';

        console.log(
          chalk.cyan(num) +
            chalk.white(version) +
            chalk.gray(timestamp) +
            chalk.white(files) +
            chalk.yellow(size) +
            latestLabel
        );
      });

      console.log(chalk.gray('‚îÄ'.repeat(70)));

      // Show summary
      const totalCost = history.deployments.reduce((sum, d) => sum + d.totalCost, 0);
      const totalSize = history.deployments.reduce((sum, d) => sum + d.totalSize, 0);
      console.log(chalk.gray(`\nTotal deployments: ${history.totalDeployments}`));
      console.log(chalk.gray(`Total cost: ~${totalCost} satoshis`));
      console.log(chalk.gray(`Total size: ${formatBytes(totalSize)}`));

      if (history.originVersioningInscription) {
        console.log(chalk.gray(`Versioning inscription: ${history.originVersioningInscription}`));
      }
      console.log();
    } catch (error) {
      console.error(chalk.red('\n‚ùå Failed to read manifest history:\n'));
      console.error(chalk.red(error instanceof Error ? error.message : String(error)));
      process.exit(1);
    }
  });

program.parse();
