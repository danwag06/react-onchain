import type { ChunkManifest } from '../chunking/index.js';

/**
 * Generates a Service Worker that handles chunk reassembly for large files
 *
 * The generated SW uses YouTube-style streaming with:
 * - ReadableStream for progressive delivery (zero-memory overhead)
 * - Cache-first strategy for individual chunks only
 * - Proper HTTP range request handling
 * - No caching of assembled responses (chunks only)
 *
 * @param manifests - Array of chunk manifests for all chunked files
 * @param baseUrl - Base URL for content delivery
 * @returns Complete Service Worker JavaScript code as a string
 */
export function generateChunkReassemblyServiceWorker(
  manifests: ChunkManifest[],
  baseUrl: string
): string {
  const manifestsJson = JSON.stringify(manifests, null, 2);

  return `
//
// Chunk Reassembly Service Worker (YouTube-style streaming)
// Generated by react-onchain
//
// Architecture:
// - Caches individual chunks only (not assembled files)
// - Uses ReadableStream for zero-memory progressive delivery
// - Handles HTTP Range requests properly for video seeking
//

const CHUNK_MANIFESTS = ${manifestsJson};
const BASE_URL = '${baseUrl}';
const CACHE_NAME = 'bsv-chunks-v1';

// Build manifest lookup map
const manifestMap = new Map();
CHUNK_MANIFESTS.forEach(manifest => {
  // Index by filename - matches requests like /content/txid_vout/video.mp4
  manifestMap.set(manifest.originalPath, manifest);
});

/* ========================================================================
   Service Worker Lifecycle
   ======================================================================== */

self.addEventListener('install', (event) => {
  console.log('[SW] Installing chunk reassembly service worker');
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  console.log('[SW] Activating chunk reassembly service worker');
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames
          .filter(name => name !== CACHE_NAME)
          .map(name => caches.delete(name))
      );
    }).then(() => self.clients.claim())
  );
});

/* ========================================================================
   Request Interception
   ======================================================================== */

self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);
  const pathname = url.pathname;

  // Find manifest by checking if pathname ends with the original filename
  const manifest = findManifest(pathname);

  if (manifest) {
    console.log('[SW] Handling chunked file:', pathname);
    event.respondWith(handleChunkedFile(event.request, manifest));
  }
  // Otherwise, let the request pass through
});

/* ========================================================================
   Manifest Lookup
   ======================================================================== */

function findManifest(pathname) {
  // Extract filename from paths like /content/txid_vout/video.mp4
  const parts = pathname.split('/');
  const filename = parts[parts.length - 1];

  // Try exact match first
  if (manifestMap.has(pathname)) {
    return manifestMap.get(pathname);
  }

  // Try filename match (most common case)
  if (manifestMap.has(filename)) {
    return manifestMap.get(filename);
  }

  // Try without leading slash
  const withoutSlash = pathname.startsWith('/') ? pathname.slice(1) : pathname;
  if (manifestMap.has(withoutSlash)) {
    return manifestMap.get(withoutSlash);
  }

  return null;
}

/* ========================================================================
   Chunk Fetcher (Cache-First Strategy)
   ======================================================================== */

async function fetchChunk(chunkUrlPath) {
  const chunkUrl = BASE_URL + chunkUrlPath;
  const cache = await caches.open(CACHE_NAME);

  // Try cache first
  const cachedResponse = await cache.match(chunkUrl);
  if (cachedResponse) {
    return cachedResponse.arrayBuffer();
  }

  // Cache miss - fetch from network
  const response = await fetch(chunkUrl);
  if (!response.ok) {
    throw new Error(\`Failed to fetch chunk: \${chunkUrl} (\${response.status})\`);
  }

  // Cache for future use (clone before consuming)
  cache.put(chunkUrl, response.clone());

  return response.arrayBuffer();
}

/* ========================================================================
   Range Calculator
   ======================================================================== */

function parseRangeHeader(rangeHeader, totalSize) {
  const match = rangeHeader.match(/bytes=(\\d+)-(\\d*)/);
  if (!match) {
    return null;
  }

  const start = parseInt(match[1], 10);
  // If no end byte specified (e.g., "bytes=0-"), use totalSize - 1 (iOS Safari does this)
  const end = match[2] !== '' ? parseInt(match[2], 10) : totalSize - 1;
  const length = end - start + 1;

  // Validate range
  if (start < 0 || end >= totalSize || start > end) {
    return null;
  }

  console.log(\`[SW] Parsed range: start=\${start}, end=\${end}, length=\${length}, totalSize=\${totalSize}\`);
  return { start, end, length };
}

function getChunksForRange(manifest, start, end) {
  const needed = [];
  let currentOffset = 0;

  // Sort chunks by index
  const sortedChunks = [...manifest.chunks].sort((a, b) => a.index - b.index);

  for (const chunk of sortedChunks) {
    const chunkStart = currentOffset;
    const chunkEnd = currentOffset + chunk.size - 1;

    // Check if chunk overlaps with requested range
    if (chunkEnd >= start && chunkStart <= end) {
      needed.push({
        chunk,
        fileStart: chunkStart,
        fileEnd: chunkEnd,
        sliceStart: Math.max(start - chunkStart, 0),
        sliceEnd: Math.min(end - chunkStart, chunk.size - 1),
      });
    }

    currentOffset += chunk.size;

    // Early exit optimization
    if (currentOffset > end) {
      break;
    }
  }

  return needed;
}

/* ========================================================================
   Stream Assembler (YouTube-style Progressive Delivery)
   ======================================================================== */

function createRangeStream(chunks, expectedLength) {
  let chunkIndex = 0;
  let cancelled = false;
  let bytesDelivered = 0;

  return new ReadableStream({
    async pull(controller) {
      // Check if cancelled
      if (cancelled) {
        return;
      }

      // All chunks delivered
      if (chunkIndex >= chunks.length) {
        // Validate we delivered the expected number of bytes (critical for iOS Safari)
        if (bytesDelivered !== expectedLength) {
          console.error(\`[SW] Byte count mismatch! Delivered \${bytesDelivered}, expected \${expectedLength}\`);
          controller.error(new Error('Content-Length mismatch'));
        } else {
          console.log(\`[SW] Stream complete: \${bytesDelivered} bytes\`);
          controller.close();
        }
        return;
      }

      const chunkInfo = chunks[chunkIndex];
      chunkIndex++;

      try {
        // Fetch chunk (from cache or network)
        const chunkBuffer = await fetchChunk(chunkInfo.chunk.urlPath);

        // Check again if cancelled during fetch
        if (cancelled) {
          return;
        }

        // Extract only the needed slice
        const slice = chunkBuffer.slice(chunkInfo.sliceStart, chunkInfo.sliceEnd + 1);
        const sliceBytes = new Uint8Array(slice);

        // Track bytes for validation
        bytesDelivered += sliceBytes.byteLength;

        // Enqueue for delivery
        controller.enqueue(sliceBytes);
      } catch (error) {
        if (!cancelled) {
          console.error('[SW] Stream error:', error);
          controller.error(error);
        }
      }
    },

    cancel(reason) {
      cancelled = true;
      console.log(\`[SW] Range stream cancelled after \${bytesDelivered} bytes:\`, reason || 'no reason');
    },
  });
}

function createFullFileStream(manifest) {
  const sortedChunks = [...manifest.chunks].sort((a, b) => a.index - b.index);
  let chunkIndex = 0;
  let cancelled = false;

  return new ReadableStream({
    async pull(controller) {
      // Check if cancelled
      if (cancelled) {
        return;
      }

      if (chunkIndex >= sortedChunks.length) {
        controller.close();
        return;
      }

      const chunk = sortedChunks[chunkIndex];
      chunkIndex++;

      try {
        const chunkBuffer = await fetchChunk(chunk.urlPath);

        // Check if cancelled during fetch
        if (cancelled) {
          return;
        }

        controller.enqueue(new Uint8Array(chunkBuffer));
      } catch (error) {
        if (!cancelled) {
          console.error('[SW] Full file stream error:', error);
          controller.error(error);
        }
      }
    },

    cancel(reason) {
      cancelled = true;
      console.log('[SW] Full file stream cancelled:', reason || 'no reason');
    },
  });
}

/* ========================================================================
   Request Handler
   ======================================================================== */

async function handleChunkedFile(request, manifest) {
  // Handle HEAD requests (iOS Safari validation)
  if (request.method === 'HEAD') {
    console.log('[SW] HEAD request for validation');
    return new Response(null, {
      status: 200,
      statusText: 'OK',
      headers: {
        'Content-Type': manifest.mimeType,
        'Content-Length': manifest.totalSize.toString(),
        'Accept-Ranges': 'bytes',
        'Cache-Control': 'public, max-age=31536000',
      },
    });
  }

  const rangeHeader = request.headers.get('Range');

  // Handle Range requests (for video seeking)
  if (rangeHeader) {
    const range = parseRangeHeader(rangeHeader, manifest.totalSize);
    if (!range) {
      console.error('[SW] Invalid range header:', rangeHeader);
      return new Response('Requested Range Not Satisfiable', {
        status: 416,
        headers: {
          'Content-Range': \`bytes */\${manifest.totalSize}\`,
        },
      });
    }

    console.log(\`[SW] Range request: bytes \${range.start}-\${range.end} (length: \${range.length})\`);

    // Calculate which chunks are needed
    const chunks = getChunksForRange(manifest, range.start, range.end);
    console.log(\`[SW] Need \${chunks.length} chunk(s) for this range\`);

    // Create streaming response with expected byte count for validation
    const stream = createRangeStream(chunks, range.length);

    return new Response(stream, {
      status: 206,
      statusText: 'Partial Content',
      headers: {
        'Content-Type': manifest.mimeType,
        'Content-Length': range.length.toString(),
        'Content-Range': \`bytes \${range.start}-\${range.end}/\${manifest.totalSize}\`,
        'Accept-Ranges': 'bytes',
      },
    });
  }

  // No range header - serve full file with streaming
  console.log('[SW] Full file request (no range header)');

  const stream = createFullFileStream(manifest);

  return new Response(stream, {
    status: 200,
    statusText: 'OK',
    headers: {
      'Content-Type': manifest.mimeType,
      'Content-Length': manifest.totalSize.toString(),
      'Accept-Ranges': 'bytes',
      'Cache-Control': 'public, max-age=31536000',
    },
  });
}

console.log('[SW] Chunk reassembly service worker loaded. Managing', CHUNK_MANIFESTS.length, 'chunked file(s).');
`.trim();
}

/**
 * Generates the HTML script tag to register the Service Worker
 *
 * This implementation fixes the race condition where videos/chunked files
 * would fail to load on first page visit because the browser would request
 * them before the service worker could intercept the requests.
 *
 * Solution: Register SW immediately (not on 'load' event) and dispatch
 * a custom event when ready. Video elements should wait for this event.
 *
 * @param swUrl - URL path to the service worker file
 * @returns HTML script tag as a string
 */
export function generateServiceWorkerRegistration(swUrl: string): string {
  return `
<script>
  // Register Service Worker for chunk reassembly
  // IMPORTANT: Registered immediately (not on 'load') to fix race condition with video loading
  // Debug mode: Add ?debug=true to URL to enable console logging
  (function() {
    const params = new URLSearchParams(window.location.search);
    const DEBUG = params.get('debug') === 'true';
    const log = DEBUG ? console.log.bind(console) : function() {};
    const error = console.error.bind(console);

    if ('serviceWorker' in navigator) {
      // Create a promise that resolves when SW is ready
      window.swReady = navigator.serviceWorker.register('${swUrl}')
        .then(registration => {
          log('[react-onchain] Chunk reassembly SW registered:', registration.scope);
          return navigator.serviceWorker.ready;
        })
        .then(() => {
          log('[react-onchain] Chunk reassembly SW active and ready');
          // Dispatch custom event for video elements to know SW is ready
          window.dispatchEvent(new CustomEvent('sw-ready'));
          return true;
        })
        .catch(err => {
          error('[react-onchain] SW registration failed:', err);
          return false;
        });
    } else {
      // No service worker support - resolve immediately
      window.swReady = Promise.resolve(false);
    }
  })();

  // Helper function for video elements to wait for SW before loading
  // Usage in your app:
  // document.addEventListener('DOMContentLoaded', () => {
  //   window.swReady.then(() => {
  //     const video = document.getElementById('my-video');
  //     const source = document.createElement('source');
  //     source.src = 'video.mp4';
  //     source.type = 'video/mp4';
  //     video.appendChild(source);
  //     video.load();
  //   });
  // });
</script>`.trim();
}
